7zit () {
    if [ ! -z $1 ]; then
        7z a -t7z -m0=lzma2 -mx=9 -mmt$(nproc) -ms=on $1.7z $1
    fi
}

certinfo () {
    openssl x509 -in $1 -text -noout
}

download () {
    userAgent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586"
    if [ ! -z $1 ]; then
        curl -A $userAgent -O -J -L -C- "$@"
    else
        echo "Pass an URL parameter."
    fi
}

epoch-to-date () {
    zmodload zsh/datetime
    strftime "%d-%B-%Y %H:%M:%S" $1
}

ftpmirror () {
    [[ -z $1 || -z $2 ]] && echo "Need two arguments" && return

    lftp -e "mirror -c -v --delete-first --parallel=2 --use-pget-n=5 -O $2; quit" $1 
}

gensshmoduli () {
    bits=8192
    if [ ! -z $1 ]; then
        if [ $1 -ge 2048 ]; then
            if [ $(( $1 & ($1 - 1) )) -eq 0 ]; then
                bits=$i
            else
                echo "$1 is not a power of 2."
                return
            fi
        else
            echo "$1 is too small, use 2048 bits or more."
            return
        fi
    fi

    echo "Producing $bits bits moduli..."
    f=$(mktemp /tmp/moduli.$bits.candidate.XXXXXX)
    ssh-keygen -G $f -b $bits
    ssh-keygen -T moduli.$bits.tested -f $f
    rm $f
    echo "$bits bit SSH moduli is ready under moduli.$bits.tested file."
}

last-modified () {
    if [ -z $1 ]; then
        return 0
    fi

    d=$(curl -L -s -I $1 | awk -F: '/Last-Modified/ {print $2}')
    local -a result

    if [ -z $d ]; then
        echo "Last-Modified header is not available :("
        return
    fi

    d1=$(date +%s)
    d2=$(date -d "$d" +%s)
    diff=$((d1 - d2))

    if [ $diff -gt 86400 ]; then
        days="$(($diff/86400))"
        diff=$(($diff - days*86400))
        result+=( "$days days" )
    fi

    if [ $diff -gt 3600 ]; then
        hours=$(($diff/3600))
        diff=$(($diff - hours*3600))
        result+=( "$hours hours" )
    fi

    if [ $diff -gt 60 ]; then
        minutes=$(($diff/60))
        diff=$(($diff - minutes*60))
        result+=( "$minutes minutes" )
    fi

    if [ $diff -gt 0 ]; then
        seconds=$diff
        result+=( "$seconds seconds" )
    fi

    echo "${(j:, :)result} ago."
}

longurl () {
    curl -w "%{url_effective}\n" -I -L -s -S $1 -o /dev/null
}

mkiso () {
    if [ ! -z $1 ]; then
        mkisofs -udf -r -J -iso-level 4 -V $1 -o ${1%/}.iso $1
    else
        echo "Please pass a directory name."
    fi
}

nomark () {
    pandoc -s -f markdown -t man $1 | groff -T utf8 -man -
}

remote-size () {
    length=$(curl -s -I -L $1 | grep Content-Length | cut -f2 -d":" | tr -d ' \r\n')
    if [ -z $length ]; then
        echo "No Content-Length header."
    else
        echo $(( $length / (1024*1024) ))"MB"
    fi
}

retry-if-fails () {
    [[ -o errexit ]] && errexit_set="1"; set +e
    retry=0
    timeout=10

    while [ $retry -le $timeout ]; do
        eval $@
        if [ $? -eq 0 ]; then
            break
        fi

        let "retry += 1"
        if [ $retry -ge $timeout ]; then
            echo "Timeout reached while trying to run command."
            break
        fi

        random_secs=$(( (( RANDOM % 1000 ) + 1) / 1000.0 ))
        sleeptime=$(( 2**$retry + $random_secs ))
        printf "Command failed, sleeping %.2f seconds before retrying.\n" $sleeptime
        sleep $sleeptime
    done

    [[ $errexit_set = "1" ]] && set -e
}

sslcheck () {
    nmap --unprivileged --system-dns --script ssl-enum-ciphers -p ${2:-443} $1
}

synconf () {
    local -a dirs
    [ -d ~/github/config ] && dirs+=("~/github/config")
    [ -d ~/github/hacks ] && dirs+=("~/github/hacks")
    [ -d ~/github/randomworks ] && dirs+=("~/github/randomworks")

    pull ${=dirs}
}

x () {
    if [ -f $1 ] ; then
      case $1 in
        *.tar.lzma|*.tar.xz|*.tar.bz2|*.tar.gz|*.tar|*.tbz2|*.tgz|*.tbz)
                     tar xvf $1     ;;
        *.lzma)
                     lzma -d $1     ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar|*.r[0-9]*)       rar x $1     ;;
        *.gz)        gunzip $1      ;;
        *.7z|*.a|*.cab|*.msi|*.iso|*.xz|*.zip)  7z x $1        ;;
        *.deb)       ar x $1 && tar xvf data.tar.xz ;;
        *.rpm)       unrpm $1 ;;
        *)     echo "'$1' cannot be extracted via x()" ;;
         esac
     fi
}

ydl () {
    for url in "$@"; do
        youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/mp4' "$url" -o %(title)s.%(ext)s
    done
}

zman () {
    PAGER="less -g -s '+/^       "$1"'" man zshall
}
