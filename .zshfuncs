backoff () {
    retry=1
    timeout=10

    while [ $retry -le $timeout ]; do
        eval $@
        if [ $? -eq 0 ]; then
            break
        fi

        sleeptime=$(( 2**$retry ))
        echo "Command failed, sleeping $sleeptime seconds before retrying."
        sleep $sleeptime
        let "retry += 1"
    done

    if [ $retry -ge $timeout ]; then
        echo "Timeout reached while trying to run command."
    fi
}

certinfo () {
    openssl x509 -in $1 -text -noout
}

digany () {
    if [ -z $1 ]; then
        echo "Pass a domain parameter."
        return
    fi

    server=8.8.8.8
    if [ ! -z $2 ]; then
        server=$2
    fi

    dig @$server +nocmd $1 any +multiline +noall +answer
}

download () {
    if [ ! -z $1 ]; then
        for url in $@; do
            curl -O -J -L -C- -# "$url"
        done
    else
        echo "Pass an URL parameter."
    fi
}

encode_film () {
    ffmpeg -i $1 -c:v libx264 -preset medium -tune film ${1:t:r}.mp4
}

gensshmoduli () {
    if [ -z $1 ]; then
        echo "Pass requested number of bits as the first parameter."
        return
    fi

    f=$(mktemp /tmp/moduli.$1.candidate.XXXXXX)
    ssh-keygen -G $f -b $1
    ssh-keygen -T moduli.$1.tested -f $f
    rm $f
    echo "$1 bit SSH moduli is ready under moduli.$1.tested file."
}

hr () {
    print ${(l:COLUMNS::=:)}
}

keygen () {
    ssh-keygen -o -a 65536 -t ed25519
}

lastmod () {
    if [ -z $1 ]; then
        return 0
    fi

    d=$(curl -L -s -I $1 | awk -F: '/Last-Modified/ {print $2}')
    local -a result

    if [ -z $d ]; then
        echo "Last-Modified header is not available :("
        return
    fi

    d1=$(date +%s)
    d2=$(date -d "$d" +%s)
    diff=$((d1 - d2))

    if [ $diff -gt 86400 ]; then
        days="$(($diff/86400))"
        diff=$(($diff - days*86400))
        result+=( "$days days" )
    fi

    if [ $diff -gt 3600 ]; then
        hours=$(($diff/3600))
        diff=$(($diff - hours*3600))
        result+=( "$hours hours" )
    fi

    if [ $diff -gt 60 ]; then
        minutes=$(($diff/60))
        diff=$(($diff - minutes*60))
        result+=( "$minutes minutes" )
    fi

    if [ $diff -gt 0 ]; then
        seconds=$diff
        result+=( "$seconds seconds" )
    fi

    echo "${(j:, :)result} ago."
}

llir () {
    t=$(mktemp --suffix=.ll)
    suffix=${1:e}
    case $suffix in
        C|c++|cpp|cxx )
            clang++ -c -S -emit-llvm -std=c++11 $1(+cyg) -o $t(+cyg) 2>/dev/null
            ;;
        c )
            clang -c -S -emit-llvm -std=c11 $1(+cyg) -o $t(+cyg) 2>/dev/null
            ;;
        * )
            echo "Unknown file extension $suffix"
            ;;
    esac

    pygmentize $t
    rm -f $t
}

longurl () {
    curl -w "%{url_effective}\n" -L -s -S $1 -o /dev/null
}

lupx () {
    upx --best --lzma $@
}

mp3 () {
    youtube-dl --extract-audio --title --audio-format mp3 "$1"
}

myip () {
    curl -s whatismyip.akamai.com
}

randfile () {
    if [ -z $1 ]; then
        echo "You need to pass a file extension."
        return
    fi

    result=$(=ls **/*.$1 2>/dev/null | shuf --random-source=/dev/urandom -n 1)
    if [ -z $result ]; then
        echo "No results."
    else
        echo $result
    fi
}

rdp () {
    common_opts=(+aero +clipboard +compression +decorations +fonts +themes +wallpaper +window-drag)
    if [ ! -z $(whence cygpath) ]; then
        wfreerdp "$@" $common_opts /drive:x,C:/
    else
        xfreerdp "$@" $common_opts /drive:x,/havana
    fi
}
       
srand () {
    if [ -e /dev/hwrng ]; then
        DEVICE="/dev/hwrng"
    else
        DEVICE="/dev/random"
    fi

    if [ -z $1 ]; then
        base64 < $DEVICE | head -c32
    else
        base64 < $DEVICE | head -c$1
    fi
    print
}

sslcheck () {
    if [ -z $2 ]; then
        nmap --system-dns --script ssl-enum-ciphers -p 443 $1
    else
        nmap --system-dns --script ssl-enum-ciphers -p $2 $1
    fi
}

sshfingerprint () {
    if [ -z $1 ]; then
        echo "Pass an hostname to get the SSH fingerprint."
        return
    fi

    for host in "$@"; do
        t=$(mktemp)
        data=("${(s/:/)host}")
        host=$data[1]
        port=$data[2]

        if [ -z $port ]; then
            ssh-keyscan -t rsa,ed25519 $host &> $t
        else
            ssh-keyscan -p $port -t rsa,ed25519 $host &> $t
        fi

        ssh-keygen -l -f $t
        rm -f $t
    done
}

synconf () {
    pull ~/config ~/hacks
}

tm () {
    tmux new-session -d "$*; sleep infinity"
}

vstream () {
    vlc "$1" --sout '#transcode{vcodec=h264,acodec=mp3,ab=128,channels=2,samplerate=44100}:http{dst=:8080/live.mpg}'
}

x () {
    if [ -f $1 ] ; then
      case $1 in
        *.tar.lzma|*.tar.xz|*.tar.bz2|*.tar.gz|*.tar|*.tbz2|*.tgz|*.tbz)
                     tar xvf $1     ;;
        *.lzma)
                     lzma -d $1     ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       unrar e $1     ;;
        *.gz)        gunzip $1      ;;
        *.zip)       unzip $1       ;;
        *.7z|*.iso)  7z x $1        ;;
        *.deb)       ar x $1 && tar xvf data.tar.xz ;;
        *)     echo "'$1' cannot be extracted via x()" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

xzit () {
    if [ ! -z $1 ]; then
        echo "Creating tar package..."
        tar --exclude-vcs -cf $1.tar $1
        echo "Compressing with xz..."
        xz -6 -T0 $1.tar
        echo "$1.tar.xz is ready!"
    fi
}

ydl () {
    for url in "$@"; do
        youtube-dl "$url" -o %(title)s.%(ext)s
    done
}

zman () {
    PAGER="less -g -s '+/^       "$1"'" man zshall
}
